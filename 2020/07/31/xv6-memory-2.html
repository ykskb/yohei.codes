<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>xv6: How exactly is memory addressed? (Part 2) | yohei.codes</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="xv6: How exactly is memory addressed? (Part 2)" />
<meta property="og:locale" content="en" />
<meta name="description" content="xv6: How exactly is memory addressed? (Part 2)" />
<meta property="og:description" content="xv6: How exactly is memory addressed? (Part 2)" />
<link rel="canonical" href="https://yohei.codes/2020/07/31/xv6-memory-2.html" />
<meta property="og:url" content="https://yohei.codes/2020/07/31/xv6-memory-2.html" />
<meta property="og:site_name" content="yohei.codes" />
<meta property="og:image" content="https://yohei.codes/assets/images/paging-mmu-diagram.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-07-31T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://yohei.codes/assets/images/paging-mmu-diagram.png" />
<meta property="twitter:title" content="xv6: How exactly is memory addressed? (Part 2)" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2020-07-31T00:00:00+00:00","datePublished":"2020-07-31T00:00:00+00:00","description":"xv6: How exactly is memory addressed? (Part 2)","headline":"xv6: How exactly is memory addressed? (Part 2)","image":"https://yohei.codes/assets/images/paging-mmu-diagram.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://yohei.codes/2020/07/31/xv6-memory-2.html"},"url":"https://yohei.codes/2020/07/31/xv6-memory-2.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://yohei.codes/feed.xml" title="yohei.codes" /><script>
if(!(window.doNotTrack === "1" || navigator.doNotTrack === "1" || navigator.doNotTrack === "yes" || navigator.msDoNotTrack === "1")) {
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-52885755-2', 'auto');
  ga('send', 'pageview');
}
</script>
  
<link rel="apple-touch-icon" sizes="180x180" href="/assets/images/favicon/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/assets/images/favicon/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/assets/images/favicon/favicon-16x16.png">
    <link rel="manifest" href="/assets/images/favicon/manifest.json">
    <link rel="mask-icon" href="/assets/images/favicon/safari-pinned-tab.svg" color="#5bbad5">
    <meta name="msapplication-TileColor" content="#da532c">
    <meta name="theme-color" content="#ffffff">
  </head><body><header class="site-header" role="banner">

    <div class="wrapper"><a class="site-title" rel="author" href="/">yohei.codes</a><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>
  
          <div class="trigger"><a class="page-link" href="/about/">About</a>
    
    [          
    
        English ]
    

    
    [          
    
        
            <a href="/jp/2020/07/31/xv6-memory-2.html">日本語</a> ]
        
    
</div>
        </nav></div>
  </header><main class="page-content" aria-label="Content">
      <div class="wrapper">
        <h1 id="xv6-how-exactly-is-memory-addressed-part-2">xv6: How exactly is memory addressed? (Part 2)</h1>

<p>This is the second article covering the memory management of xv6, continuing from <a href="/2020/06/18/xv6-memory-1.html">the previous article</a> which covered the memory management at the early stages of xv6’s kernel initialization before getting into its main function.</p>

<p>In this article, the memory management mechanism in both kernel mode and user mode is covered. Specifically xv6 uses 2-level memory paging supported by MMU (memory management unit). This is essentially the same mechanism that Linux kernel manages its memory though the number of levels is different.</p>

<h2 id="mainc">main.c</h2>

<p>Once <code class="language-plaintext highlighter-rouge">entry.S</code> jumps to <code class="language-plaintext highlighter-rouge">main</code> function, it starts with the memory management setup. The first two functions, <code class="language-plaintext highlighter-rouge">kinit1</code> and <code class="language-plaintext highlighter-rouge">kvmalloc</code> set up the 2-level paging mechanism for kernel mode. After all the device initialization and interrupt setup, <code class="language-plaintext highlighter-rouge">kinit2</code> and <code class="language-plaintext highlighter-rouge">userinit</code> functions set up the memory for user mode.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">kinit1</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">P2V</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">));</span> <span class="c1">// phys page allocator</span>
  <span class="n">kvmalloc</span><span class="p">();</span>      <span class="c1">// kernel page table</span>
  <span class="p">...</span> <span class="n">device</span> <span class="n">initialization</span> <span class="p">...</span>
  <span class="n">kinit2</span><span class="p">(</span><span class="n">P2V</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">),</span> <span class="n">P2V</span><span class="p">(</span><span class="n">PHYSTOP</span><span class="p">));</span> <span class="c1">// must come after startothers()</span>
  <span class="n">userinit</span><span class="p">();</span>      <span class="c1">// first user process</span>
  <span class="n">mpmain</span><span class="p">();</span>        <span class="c1">// finish this processor's setup</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="kernel-mode">Kernel Mode</h2>

<p>Let’s take a look at the memory setup for kernel mode first. Going through it would cover the fundamentals of paging setup and actually the kernel page mapping is used in user mode memory setup as well.</p>

<h3 id="memory-allocation">Memory Allocation</h3>

<p>The first line of <code class="language-plaintext highlighter-rouge">main</code> function runs <code class="language-plaintext highlighter-rouge">kinit1</code> function which takes <code class="language-plaintext highlighter-rouge">*vstart</code> and <code class="language-plaintext highlighter-rouge">*vend</code> arguments. The call is made to allocate the memory from <code class="language-plaintext highlighter-rouge">end</code> (first address after kernel loaded from ELF file) to <code class="language-plaintext highlighter-rouge">P2V(4*1024*1024)</code> which would be <code class="language-plaintext highlighter-rouge">0x80400000</code> (4MB from KERNBASE: 0x80000000). <code class="language-plaintext highlighter-rouge">kinit1</code> function allocates memory space as follows:</p>

<blockquote>
  <p><strong>Notes</strong></p>
  <ul>
    <li>As covered in the <a href="/2020/06/18/xv6-memory-1.html">part 1</a>, kernel instructions are based on the virtual address of <code class="language-plaintext highlighter-rouge">0x80100000</code>.</li>
    <li>At this point, the kernel is still using the 2-level mapping, <code class="language-plaintext highlighter-rouge">entrypgdir</code>.</li>
  </ul>
</blockquote>

<p>Firstly <code class="language-plaintext highlighter-rouge">kinit1</code> calls <code class="language-plaintext highlighter-rouge">freerange</code> after initializing lock for the data structure of kernel memory:</p>

<p>kalloc.c</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">kinit1</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vstart</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vend</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">initlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="s">"kmem"</span><span class="p">);</span>
  <span class="n">kmem</span><span class="p">.</span><span class="n">use_lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">freerange</span><span class="p">(</span><span class="n">vstart</span><span class="p">,</span> <span class="n">vend</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">freerange</code> calls <code class="language-plaintext highlighter-rouge">kfree</code> until <code class="language-plaintext highlighter-rouge">vend</code> by every <code class="language-plaintext highlighter-rouge">PGSIZE</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">freerange</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vstart</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">vend</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">PGROUNDUP</span><span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="n">vstart</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(;</span> <span class="n">p</span> <span class="o">+</span> <span class="n">PGSIZE</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">vend</span><span class="p">;</span> <span class="n">p</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">)</span>
    <span class="n">kfree</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">kfree</code> casts the specified pointer to <code class="language-plaintext highlighter-rouge">run</code> struct which is a single-linked list and push it into the head of <code class="language-plaintext highlighter-rouge">kmem.freelist</code>. Subsequently <code class="language-plaintext highlighter-rouge">kalloc</code> function is used to retrieve the pointer to the requested page from <code class="language-plaintext highlighter-rouge">kmem.freelist</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">run</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">run</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="kt">void</span>
<span class="nf">kfree</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// Fill with junk to catch dangling refs.</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>

  <span class="k">if</span><span class="p">(</span><span class="n">kmem</span><span class="p">.</span><span class="n">use_lock</span><span class="p">)</span>
    <span class="n">acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
  <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">run</span><span class="o">*</span><span class="p">)</span><span class="n">v</span><span class="p">;</span>
  <span class="n">r</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span><span class="p">;</span>
  <span class="n">kmem</span><span class="p">.</span><span class="n">freelist</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
  <span class="k">if</span><span class="p">(</span><span class="n">kmem</span><span class="p">.</span><span class="n">use_lock</span><span class="p">)</span>
    <span class="n">release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">kmem</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="2-level-paging">2-level Paging</h3>

<p>We have covered how kernel allocates memory for a range by pages. Now let’s look into <code class="language-plaintext highlighter-rouge">kvmalloc</code> to find out how the 2-level paging is set up.</p>

<blockquote>
  <p>Once you search “paging x86” or something similar online, we see this common diagram as below explaining how a virtual address is split into 3 different parts, eventually forming a physical address. At a glance, I got the idea of this conversion from virtual addresses to physical addresses, however I had difficulty understanding how an OS would make use of it.
<img src="/assets/images/paging-mmu-diagram.png" alt="paging-mmu-diagram" />
The key point here is to understand that an OS needs to setup these maps. Specifically an OS would allocate one page for a page directory and another for page table first, and it maps the arbitrary virtual address to the targeted physical address by creating the page directory entries and the page table entries. It’s also important to understand this mapping is based on the page directory address which would be stored in <code class="language-plaintext highlighter-rouge">CR3</code> register. So switching the <code class="language-plaintext highlighter-rouge">CR3</code> register value would change the virtual-to-physical mapping and xv6 does it per process. This whole flow is exactly what <code class="language-plaintext highlighter-rouge">kvmalloc</code> function does and its details are explained as follows.</p>
</blockquote>

<p>Firstly, <code class="language-plaintext highlighter-rouge">kvmalloc</code> calls <code class="language-plaintext highlighter-rouge">setupkvm</code> which sets up the 2-level memory paging structure. It starts by allocating a new page directory, <code class="language-plaintext highlighter-rouge">pgdir</code> by calling <code class="language-plaintext highlighter-rouge">kalloc</code>. After that, the key function here is <code class="language-plaintext highlighter-rouge">mappages</code> which sets a range of physical addresses into the page tables in a specified page directory and a starting virtual address:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pde_t</span><span class="o">*</span>
<span class="nf">setupkvm</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">kmap</span> <span class="o">*</span><span class="n">k</span><span class="p">;</span>

  <span class="k">if</span><span class="p">((</span><span class="n">pgdir</span> <span class="o">=</span> <span class="p">(</span><span class="n">pde_t</span><span class="o">*</span><span class="p">)</span><span class="n">kalloc</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// allocates a page for the page directory</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">P2V</span><span class="p">(</span><span class="n">PHYSTOP</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">DEVSPACE</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"PHYSTOP too high"</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(</span><span class="n">k</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="o">&amp;</span><span class="n">kmap</span><span class="p">[</span><span class="n">NELEM</span><span class="p">(</span><span class="n">kmap</span><span class="p">)];</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span><span class="p">(</span><span class="n">mappages</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">virt</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">phys_end</span> <span class="o">-</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">phys_start</span><span class="p">,</span>
                <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="n">k</span><span class="o">-&gt;</span><span class="n">phys_start</span><span class="p">,</span> <span class="n">k</span><span class="o">-&gt;</span><span class="n">perm</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">freevm</span><span class="p">(</span><span class="n">pgdir</span><span class="p">);</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="k">return</span> <span class="n">pgdir</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">mappages</code> writes physical address into the page table entries by a page size and loops till it writes all the pages in the specified size. Page table entries are retrieved by another function, <code class="language-plaintext highlighter-rouge">walkpgdir</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span>
<span class="nf">mappages</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="n">uint</span> <span class="n">size</span><span class="p">,</span> <span class="n">uint</span> <span class="n">pa</span><span class="p">,</span> <span class="kt">int</span> <span class="n">perm</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">;</span>
  <span class="n">pte_t</span> <span class="o">*</span><span class="n">pte</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">PGROUNDDOWN</span><span class="p">((</span><span class="n">uint</span><span class="p">)</span><span class="n">va</span><span class="p">);</span>
  <span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">PGROUNDDOWN</span><span class="p">(((</span><span class="n">uint</span><span class="p">)</span><span class="n">va</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">for</span><span class="p">(;;){</span>
    <span class="k">if</span><span class="p">((</span><span class="n">pte</span> <span class="o">=</span> <span class="n">walkpgdir</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pte</span> <span class="o">&amp;</span> <span class="n">PTE_P</span><span class="p">)</span>
      <span class="n">panic</span><span class="p">(</span><span class="s">"remap"</span><span class="p">);</span>
    <span class="o">*</span><span class="n">pte</span> <span class="o">=</span> <span class="n">pa</span> <span class="o">|</span> <span class="n">perm</span> <span class="o">|</span> <span class="n">PTE_P</span><span class="p">;</span> <span class="c1">// writes physical address on retrieved page table entry</span>
    <span class="k">if</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">last</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="n">a</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">;</span>
    <span class="n">pa</span> <span class="o">+=</span> <span class="n">PGSIZE</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">walkpgdir</code> firstly makes the pointer to the page directory entry, <code class="language-plaintext highlighter-rouge">pde</code> from the pointer to the page directory, <code class="language-plaintext highlighter-rouge">pgdir</code> and the specified virtual address, <code class="language-plaintext highlighter-rouge">va</code> using its highest 10 bits. Then it checks with <code class="language-plaintext highlighter-rouge">PTE_P</code> flag if the page directory entry has already been allocated or not. If it’s present, it means the page directory entry already has the pointer value to the page table, so it dereferences the pointer to the page table from the page directory entry. If it’s not present, it allocates a new page for the page table, and write its address on the page directory entry. Lastly, it returns the pointer to the page table entry specified with the page table and the specified virtual address using its 10 bits in the middle:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="n">pte_t</span> <span class="o">*</span>
<span class="nf">walkpgdir</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">va</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">pde_t</span> <span class="o">*</span><span class="n">pde</span><span class="p">;</span>
  <span class="n">pte_t</span> <span class="o">*</span><span class="n">pgtab</span><span class="p">;</span>

  <span class="n">pde</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pgdir</span><span class="p">[</span><span class="n">PDX</span><span class="p">(</span><span class="n">va</span><span class="p">)];</span> <span class="c1">// creates a pointer to the page directory entry</span>
  <span class="k">if</span><span class="p">(</span><span class="o">*</span><span class="n">pde</span> <span class="o">&amp;</span> <span class="n">PTE_P</span><span class="p">){</span>
    <span class="n">pgtab</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span><span class="o">*</span><span class="p">)</span><span class="n">P2V</span><span class="p">(</span><span class="n">PTE_ADDR</span><span class="p">(</span><span class="o">*</span><span class="n">pde</span><span class="p">));</span> <span class="c1">// creates a page table from the page directory entry</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">alloc</span> <span class="o">||</span> <span class="p">(</span><span class="n">pgtab</span> <span class="o">=</span> <span class="p">(</span><span class="n">pte_t</span><span class="o">*</span><span class="p">)</span><span class="n">kalloc</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="c1">// creates a page table</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// Make sure all those PTE_P bits are zero.</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">pgtab</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
    <span class="c1">// The permissions here are overly generous, but they can</span>
    <span class="c1">// be further restricted by the permissions in the page table</span>
    <span class="c1">// entries, if necessary.</span>
    <span class="o">*</span><span class="n">pde</span> <span class="o">=</span> <span class="n">V2P</span><span class="p">(</span><span class="n">pgtab</span><span class="p">)</span> <span class="o">|</span> <span class="n">PTE_P</span> <span class="o">|</span> <span class="n">PTE_W</span> <span class="o">|</span> <span class="n">PTE_U</span><span class="p">;</span> <span class="c1">// writes the address to the page table on the page directory entry</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">&amp;</span><span class="n">pgtab</span><span class="p">[</span><span class="n">PTX</span><span class="p">(</span><span class="n">va</span><span class="p">)];</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We have covered the workflow of setting up the 2-level paging. Now we should look into the actual mapping created for the kernel:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="k">struct</span> <span class="n">kmap</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">virt</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">phys_start</span><span class="p">;</span>
  <span class="n">uint</span> <span class="n">phys_end</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">perm</span><span class="p">;</span>
<span class="p">}</span> <span class="n">kmap</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
 <span class="p">{</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">KERNBASE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>             <span class="n">EXTMEM</span><span class="p">,</span>    <span class="n">PTE_W</span><span class="p">},</span> <span class="c1">// I/O space</span>
 <span class="p">{</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">KERNLINK</span><span class="p">,</span> <span class="n">V2P</span><span class="p">(</span><span class="n">KERNLINK</span><span class="p">),</span> <span class="n">V2P</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">0</span><span class="p">},</span>     <span class="c1">// kern text+rodata</span>
 <span class="p">{</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span>     <span class="n">V2P</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>     <span class="n">PHYSTOP</span><span class="p">,</span>   <span class="n">PTE_W</span><span class="p">},</span> <span class="c1">// kern data+memory</span>
 <span class="p">{</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">DEVSPACE</span><span class="p">,</span> <span class="n">DEVSPACE</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>         <span class="n">PTE_W</span><span class="p">},</span> <span class="c1">// more devices</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The actual addresses of the mapping above look like this:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">KERNBASE</code> (0x80000000) to physical: <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">EXTMEM</code> (0x100000)</li>
  <li><code class="language-plaintext highlighter-rouge">KERNLINK</code> (0x80100000) to physical: <code class="language-plaintext highlighter-rouge">KERNLINK</code> (0x100000) to <code class="language-plaintext highlighter-rouge">V2P(data)</code> (rodata in kernel image)</li>
  <li><code class="language-plaintext highlighter-rouge">data</code> to physical: <code class="language-plaintext highlighter-rouge">V2P(data)</code> to <code class="language-plaintext highlighter-rouge">PHYSTOP</code> (0xE000000: 235MB)</li>
  <li><code class="language-plaintext highlighter-rouge">DEVSPACE</code> (0xFE000000) to physical: <code class="language-plaintext highlighter-rouge">DEVSPACE</code> (0xFE000000) to <code class="language-plaintext highlighter-rouge">0</code></li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">kvmalloc</code> function creates the memory mapping as above, and calls <code class="language-plaintext highlighter-rouge">switchkvm</code> function which activates it by writing the address of the returned page directory on <code class="language-plaintext highlighter-rouge">CR3</code> register. The execution proceeds straight as the virtual address mapping to the physical kernel instructions are the same as the previous page directory, <code class="language-plaintext highlighter-rouge">pgdir</code>.</p>

<h2 id="user-mode">User Mode</h2>

<p>Back in the kernel’s <code class="language-plaintext highlighter-rouge">main</code> function, there are two calls made for user processes: <code class="language-plaintext highlighter-rouge">kinit2(P2V(4*1024*1024), P2V(PHYSTOP))</code> and <code class="language-plaintext highlighter-rouge">userinit()</code>. The first call is for allocating the memory from <code class="language-plaintext highlighter-rouge">0x80400000</code> to <code class="language-plaintext highlighter-rouge">0x8E000000</code>. The second call takes care of multiple things for a process including context, memory, and trap frame.</p>

<p>We can see <code class="language-plaintext highlighter-rouge">userinit</code> function calling <code class="language-plaintext highlighter-rouge">setupkvm</code> function below. This is to enable the switch to kernel mode for system calls and interrupts without switching the page directories.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">userinit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">proc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
  <span class="k">extern</span> <span class="kt">char</span> <span class="n">_binary_initcode_start</span><span class="p">[],</span> <span class="n">_binary_initcode_size</span><span class="p">[];</span>

  <span class="n">p</span> <span class="o">=</span> <span class="n">allocproc</span><span class="p">();</span>

  <span class="n">initproc</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pgdir</span> <span class="o">=</span> <span class="n">setupkvm</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"userinit: out of memory?"</span><span class="p">);</span>
  <span class="n">inituvm</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">pgdir</span><span class="p">,</span> <span class="n">_binary_initcode_start</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">_binary_initcode_size</span><span class="p">);</span>
  <span class="p">...</span>
</code></pre></div></div>

<p>Once <code class="language-plaintext highlighter-rouge">setupkvm</code> sets up the page tables for kernal codes, <code class="language-plaintext highlighter-rouge">userinit</code> calls <code class="language-plaintext highlighter-rouge">inituvm</code>, passing the page directory created and a pointer to and the size of <code class="language-plaintext highlighter-rouge">initcode</code>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">inituvm</span><span class="p">(</span><span class="n">pde_t</span> <span class="o">*</span><span class="n">pgdir</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">init</span><span class="p">,</span> <span class="n">uint</span> <span class="n">sz</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">mem</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="n">sz</span> <span class="o">&gt;=</span> <span class="n">PGSIZE</span><span class="p">)</span>
    <span class="n">panic</span><span class="p">(</span><span class="s">"inituvm: more than a page"</span><span class="p">);</span>
  <span class="n">mem</span> <span class="o">=</span> <span class="n">kalloc</span><span class="p">();</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">);</span>
  <span class="n">mappages</span><span class="p">(</span><span class="n">pgdir</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PGSIZE</span><span class="p">,</span> <span class="n">V2P</span><span class="p">(</span><span class="n">mem</span><span class="p">),</span> <span class="n">PTE_W</span><span class="o">|</span><span class="n">PTE_U</span><span class="p">);</span>
  <span class="n">memmove</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">init</span><span class="p">,</span> <span class="n">sz</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">inituvm</code> calls <code class="language-plaintext highlighter-rouge">kalloc</code> function to allocate a new page and resets its content to <code class="language-plaintext highlighter-rouge">0</code>. After that, it calls <code class="language-plaintext highlighter-rouge">mappages</code> with the virtual address <code class="language-plaintext highlighter-rouge">0</code> and the physical address of the new page, which means the virtual address <code class="language-plaintext highlighter-rouge">0</code> would be pointing to this new page in this page directory. Lastly <code class="language-plaintext highlighter-rouge">memmove</code> is called to write the <code class="language-plaintext highlighter-rouge">init</code> codes into the newly allocated page. This achieves the memory structure for a user process where it can just start with the <code class="language-plaintext highlighter-rouge">EIP</code> from <code class="language-plaintext highlighter-rouge">0</code> while keeping the access to kernel pages.</p>

<h2 id="summary">Summary</h2>

<p>It became quite a lengthy article, but I hope I could cover how memory is managed by xv6 using the 2-level paging structure step-by-step. It was a good exercise for myself to organize my learnings as well. I hope someone would find it useful.</p>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">yohei.codes</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">yohei.codes</li><li><a class="u-email" href="mailto:me@yohei.codes">me@yohei.codes</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/ykskb"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">ykskb</span></a></li><li><a href="https://www.linkedin.com/in/yohei-kusakabe"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#linkedin"></use></svg> <span class="username">yohei-kusakabe</span></a></li><li><a href="https://www.twitter.com/yo__ohei"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">yo__ohei</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>I enjoy computer science stuff.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
